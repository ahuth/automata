{"version":3,"sources":["components/Grid.tsx","rule.ts","components/BitSelector.tsx","components/RuleSelector.tsx","row.ts","world.ts","automata.ts","components/App.tsx","index.ts"],"names":["Grid","rows","style","styles","container","map","row","index","value","off","on","display","flexDirection","backgroundColor","height","width","create","inputs","output","machineReadableInputs","rule","join","humanReadableInputs","BitSelector","toggle","handleChange","useCallback","Rule","input","aria-label","checked","onChange","type","border","RuleSelector","rules","toggleRule","outputBits","ruleNumber","parseInt","selectors","justifyContent","size","Array","fill","Math","floor","length","next","array","prevIndex","nextIndex","eachNeighborhood","neighbors","find","Row","i","nextRow","push","automata","serializedOutputs","nextRules","World","initialAutomata","Automata","App","useState","setAutomata","serializedInputs","Fragment","href","ReactDOM","render","React","createElement","document","getElementById"],"mappings":"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","file":"static/js/main.601c5519.chunk.js","sourcesContent":["import React from 'react';\nimport { Type as Row } from '../row';\n\ntype Props = {\n  rows: Row[],\n};\n\nexport default function Grid({ rows }: Props) {\n  return (\n    <div style={styles.container}>\n      {rows.map(function (row, index) {\n        return (\n          <div key={index} style={styles.row}>\n            {row.map(function (value, index) {\n              return <div key={index} style={value === 0 ? styles.off : styles.on} />;\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nconst styles = {\n  container: {\n    display: 'flex',\n    flexDirection: 'column' as const,\n  },\n  row: {\n    display: 'flex',\n  },\n  on: {\n    backgroundColor: 'black',\n    height: 8,\n    width: 8,\n  },\n  off: {\n    backgroundColor: 'white',\n    height: 8,\n    width: 8,\n  },\n};\n","type Rule = {\n  inputs: number[],\n  output: number,\n};\n\nexport type Type = Rule;\n\nexport function create(inputs: number[], output: number): Rule {\n  return { inputs, output };\n}\n\nexport function machineReadableInputs(rule: Rule): string {\n  return rule.inputs.join('');\n}\n\nexport function humanReadableInputs(rule: Rule): string {\n  return rule.inputs.join();\n}\n\nexport function toggle(rule: Rule): Rule {\n  return {\n    ...rule,\n    output: rule.output === 0 ? 1 : 0,\n  };\n}\n\nexport function find(rules: Rule[], neighbors: number[]): Rule {\n  const matchingRule = rules.find(function (rule) {\n    return machineReadableInputs(rule) === neighbors.join('');\n  });\n\n  return matchingRule || { inputs: [], output: 0 };\n}\n","import React, { useCallback } from 'react';\nimport * as Rule from '../rule';\n\ntype Props = {\n  rule: Rule.Type,\n  toggle: (inputs: string) => void,\n};\n\nexport default function BitSelector({ rule, toggle }: Props) {\n  const { inputs, output } = rule;\n\n  const handleChange = useCallback(function () {\n    toggle(Rule.machineReadableInputs(rule));\n  }, [rule, toggle]);\n\n  return (\n    <div style={styles.container}>\n      <div style={styles.inputs}>\n        {inputs.map(function (input, index) {\n          return <div style={input === 0 ? styles.off : styles.on} key={index} />;\n        })}\n      </div>\n      <input\n        aria-label={Rule.humanReadableInputs(rule)}\n        checked={output === 0 ? false : true}\n        onChange={handleChange}\n        type=\"checkbox\"\n      />\n    </div>\n  );\n}\n\nconst styles = {\n  container: {\n    display: 'flex',\n    flexDirection: 'column' as const,\n  },\n  inputs: {\n    display: 'flex',\n  },\n  on: {\n    backgroundColor: 'black',\n    border: '1px solid black',\n    height: 8,\n    width: 8,\n  },\n  off: {\n    backgroundColor: 'white',\n    border: '1px solid black',\n    height: 8,\n    width: 8,\n  },\n};\n","import React from 'react';\nimport BitSelector from './BitSelector';\nimport * as Rule from '../rule';\n\ntype Props = {\n  rules: Rule.Type[],\n  toggleRule: (inputs: string) => void,\n};\n\nexport default function RuleSelector({ rules, toggleRule }: Props) {\n  const outputBits = rules.map(rule => rule.output);\n  const ruleNumber = parseInt(outputBits.join(''), 2);\n\n  return (\n    <fieldset style={styles.container}>\n      <legend>Automata Rule</legend>\n      <div style={styles.selectors}>\n        {rules.map(function (rule) {\n          return <BitSelector key={Rule.machineReadableInputs(rule)} rule={rule} toggle={toggleRule} />;\n        })}\n      </div>\n      <span>Rule {ruleNumber}</span>\n    </fieldset>\n  );\n}\n\nconst styles = {\n  container: {\n    width: 600,\n  },\n  selectors: {\n    display: 'flex',\n    justifyContent: 'space-between',\n  },\n};\n","import * as Rule from './rule';\n\ntype Row = number[];\n\nexport type Type = Row;\n\nexport function create(size: number): Row {\n  const row = new Array(size).fill(0);\n  const middle = Math.floor(row.length / 2);\n  row[middle] = 1;\n  return row;\n}\n\nexport function next(row: Row, rules: Rule.Type[]): Row {\n  return eachNeighborhood(row).map(function (neighbors) {\n    const rule = Rule.find(rules, neighbors);\n    return rule.output;\n  });\n}\n\nfunction eachNeighborhood(row: Row): number[][] {\n  return row.map(function (value, index, array) {\n    const prevIndex = index - 1;\n    const nextIndex = index + 1;\n\n    const prevValue = prevIndex < 0 ? 0 : array[prevIndex];\n    const nextValue = nextIndex >= array.length ? 0 : array[nextIndex];\n\n    return [prevValue, value, nextValue];\n  });\n}\n","import * as Row from './row';\nimport * as Rule from './rule';\n\ntype World = Row.Type[];\n\nexport type Type = World;\n\nexport function create(height: number, width: number, rules: Rule.Type[]): World {\n  const rows = [Row.create(width)];\n\n  for (let i = 0; i < height; i++) {\n    const lastRow = rows[rows.length - 1];\n    const nextRow = Row.next(lastRow, rules);\n    rows.push(nextRow);\n  }\n\n  return rows;\n}\n","import * as Rule from './rule';\nimport * as World from './world';\n\ntype Automata = {\n  height: number,\n  width: number,\n  rows: World.Type,\n  rules: Rule.Type[],\n};\n\nexport type Type = Automata;\n\nexport function create(height: number, width: number): Automata {\n  const rules = [\n    Rule.create([1, 1, 1], 0),\n    Rule.create([1, 1, 0], 0),\n    Rule.create([1, 0, 1], 0),\n    Rule.create([1, 0, 0], 1),\n    Rule.create([0, 1, 1], 1),\n    Rule.create([0, 1, 0], 1),\n    Rule.create([0, 0, 1], 1),\n    Rule.create([0, 0, 0], 0),\n  ];\n\n  return {\n    height,\n    width,\n    rows: World.create(height, width, rules),\n    rules,\n  };\n}\n\nexport function toggleRule(automata: Automata, serializedOutputs: string): Automata {\n  const nextRules = automata.rules.map(function (rule) {\n    if (Rule.machineReadableInputs(rule) === serializedOutputs) {\n      return Rule.toggle(rule);\n    }\n    return rule;\n  });\n\n  return {\n    ...automata,\n    rows: World.create(automata.height, automata.width, nextRules),\n    rules: nextRules,\n  };\n}\n","import React, { useCallback, useState } from 'react';\nimport Grid from './Grid';\nimport RuleSelector from './RuleSelector';\nimport * as Automata from '../automata';\n\nconst initialAutomata = Automata.create(63, 127);\n\nexport default function App() {\n  const [automata, setAutomata] = useState(initialAutomata);\n\n  const toggleRule = useCallback(function (serializedInputs: string) {\n    setAutomata(\n      Automata.toggleRule(automata, serializedInputs),\n    );\n  }, [automata]);\n\n  return (\n    <React.Fragment>\n      <RuleSelector rules={automata.rules} toggleRule={toggleRule} />\n      <aside>\n        <p>Some of the more interesting rules are: 30, 54, 60, 62, 90, 94, 102, 110, 122, 126, 150, 158, 182, 188, 190, 222.</p>\n        <p>View the source code at <a href=\"https://github.com/ahuth/automata\">https://github.com/ahuth/automata</a>.</p>\n      </aside>\n      <hr />\n      <Grid rows={automata.rows} />\n    </React.Fragment>\n  );\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport './index.css';\n\nReactDOM.render(React.createElement(App), document.getElementById('root'));\n"],"sourceRoot":""}